---
title: "fasta2nuccomp"
author: "Insert authors here"
date: "`r format(Sys.time(), '%Y, %B %d')`"
output:
  html_document:
    toc: true
    code_folding: show
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.align = "center")
knitr::opts_chunk$set(fig.height = 4)
knitr::opts_chunk$set(fig.width = 4)
#library(reticulate)
#use_python("/usr/bin/python3")
#use_python("/usr/bin/env python3")
st1 <- Sys.time()
```




The repository ```fasta2nuccomp``` includes tools to help investigators rapidly summarize the contents of a file in the FASTA format.
The python script ```fasta2nuccomp.py``` can be run independently or called from Rmarkdown, as we will see in this document.


## Dependencies


The script ```fasta2nuccomp.py``` was written in python 3.7.3 and biopython 1.78.
You'll want versions that are greater or equal to these versions.
Below we see how to query the versions we have.


From an ```R``` prompt we can query which version of ```python``` we have installed.


```{r system_python}
my_python <- system("python3 -V", intern = TRUE)
my_python
```


From an interactive ```python``` prompt we can query which version of Biopython we have installed.


```{r include=FALSE}
options(prompt = '>>> ')
```


```{python biopython_check, prompt=TRUE, eval=FALSE}
import Bio
print(Bio.__version__)
```


```{r include=FALSE}
options(prompt = '> ')
```


We'll also want at least R 4.0.2.
You should see the version you have when you start R.
We'll also see how to get this information in the section 'Session information.'
You do not need RStudio, but I highly recommend it.


## FASTA file

Nucleotide data is typically stored in a FASTA format file.
This is a text file with a specific format.
A description line begins with '>' and is followed by one or more lines of sequence.
You can learn more about the FASTA format at Wikipedia's [FASTA format](https://en.wikipedia.org/wiki/FASTA_format) page.
The yeast (*Saccharomyces cerevisiae*) strain S288C genome is included with ```fasta2nuccomp``` as an example FASTA file.


## Summarizing a FASTA file


In order to summarize our FASTA file we will call ```fasta2nuccomp.py``` from the shell.
It requires that you tell it the name of your FASTA file.
If the script `fasta2nuccomp.py` is not in your path and not in the path in the below code chunck, you'll have to change the call to reflect it's location on your system.


```{r}
st2 <- Sys.time()
my_infile <- "S288C_reference_sequence_R64-2-1_20150113.fsa.gz"
my_out <- basename(my_infile)
my_out <- sub("\\.gz$", "", my_out)
my_out <- sub("\\.fna$", "", my_out)
my_out <- sub("\\.fasta$", "", my_out)
# Only run python script if it's outfile does not exist. 
if( !file.exists( paste(my_out, "_nuccomp.csv", sep = "") ) ){
  system(paste("~/gits/fasta2nuccomp/fasta2nuccomp.py", my_infile))
}
```


```{r}
st3 <- Sys.time()
st3-st2
```


This will create a comma delimited text file that has the same name as your FASTA file with the added suffix ```_nuccomp.csv```.


## Post-processing


Once we have summarized our FASTA data we'll want to present it.
This can be accomplished with summary statistics and graphics.
Here we demonstrate how to summarize this data.
Note that the end user may have to adjust the manual placement of text in each plot as well as the binwidth used for the histograms.


```{r}
my_nucs <- readr::read_csv(paste(my_out, "_nuccomp.csv", sep = ""))
my_nucs
```


This FASTA file consists of `r format(sum(my_nucs$Length), big.mark=",")` nucleotides organized in `r format(length(my_nucs$Length), big.mark=",")` chromosomes or contigs.
The longest contig is `r format(max(my_nucs$Length), big.mark=",")` bp and the shortest is `r format(min(my_nucs$Length), big.mark=",")`.
We can visualize this information in a semi-automated manner using histograms.


## N50


The summary statistic N50 has become a popular way to summarize the contiguity of a genome assembly.
If we sum the entire number of nucleotides in an assembly and divide this number by two we get half of the assembly size.
If we then sort the chromosomes or contigs in order of length, from longest to shortest, and walk through these until we reach the point of half of the assembly size we can report the length of the contig that contains this nucleotide.
If this contig is long we may conclude that this is a well assembled genome that approaches chromosomes.
If this contig is short we may conclude that this assembly does not approach chromosomes and may have quality issues.
In R we can calculate N50 as follows.


```{r}
my_lens <- sort(my_nucs$Length, decreasing = TRUE)
my_mid <- sum(my_lens)/2

n50 <- my_lens[cumsum(my_lens) >= my_mid][1]

format(n50, big.mark = ",")
```



## Visualization


Graphical summaries can be created in R as follows.


```{r}
library(ggplot2)
```


```{r}
my_df <- data.frame(Length = my_nucs$Length,
                    GC = rowSums(my_nucs[,c("c", "C", "g", "G")])
                    )

my_max <- max(my_df$Length)
my_med <- median(my_df$Length)
my_min <- min(my_df$Length)
my_seqs <- length(my_df$Length)
my_nzero <- length(my_df$Length > 0)
my_nna <- length(!is.na(my_df$Length))
my_len <- sum(my_df$Length)

#my_df$GC <- my_df$GC/my_df$Length
#
my_denom <- 1e3
my_df$Length <- my_df$Length/my_denom


my_text <- paste("Nucleotides:\n", format(my_len, big.mark = ","),
                 "\nN50: ", format(n50, big.mark = ","),
                 "\nN seqs: ", format(my_seqs, big.mark = ","),
                 "\nMax: ", format(my_max, big.mark = ","),
                 "\nMedian: ", format(my_med, big.mark = ","),
                 "\nMin: ", format(my_min, big.mark = ","),
                 sep = ""
                 )
```


```{r}

pl <- ggplot(my_df, aes(x = Length))
#pl <- pl + geom_histogram(binwidth=2e4, fill = "blue")

pl <- pl + geom_histogram(binwidth = 2e1, fill = "blue")
pl <- pl + theme_bw()
pl <- pl + geom_vline(xintercept = n50/my_denom, color = "#B22222", size = 1.5,
                      linetype="dashed")
my_ymax <- max(ggplot_build(pl)$data[[1]]$y)/2
#
pl <- pl + annotate("text", x = my_max/my_denom * 0.95, y = my_ymax,
                    label = my_text, adj = 1)

pl <- pl + xlab("Length (Kbp)")
pl <- pl + ylab("Count")

pl
```


Maximum value: `r format(max(my_nucs$Length), big.mark=",")`;   
median value: `r format(median(my_nucs$Length), big.mark=",")`;   
minimum value: `r format(min(my_nucs$Length), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   



```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("a","A")])/my_nucs$Length)
names(my_df) <- "nucs"
my_med <- median(my_df$nucs)

pua <- sum(my_nucs[,c("A")])/sum(rowSums(my_nucs[,c("a","A")]))

my_text <- paste("Median: ", round(my_med, 3),
                 "\nUppercase: ", round(pua * 100, 1),
                 "%",
                 sep = ""
                 )


pa <- ggplot(my_df, aes(x = nucs))
pa <- pa + geom_histogram(binwidth=0.01, fill = "#5157FB")
pa <- pa + theme_bw()
pa <- pa + xlim(c(0,1))
pa <- pa + xlab("Adenine (A, a)")
#pa <- pa + annotate("text", x = 0.95, y=1.5, label= my_text, adj = 1)
my_ymax <- max(ggplot_build(pa)$data[[1]]$y)/2
pa <- pa + annotate("text", x = 0.95, y=my_ymax, label= my_text, adj = 1)
pa <- pa + ylab("Count")

pa
```

Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   



```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("c","C")])/my_nucs$Length)
names(my_df) <- "nucs"
my_med <- median(my_df$nucs)

puc <- sum(my_nucs[,c("C")])/sum(rowSums(my_nucs[,c("c","C")]))

my_text <- paste("Median: ", round(my_med, 3),
                 "\nUppercase: ", round(puc * 100, 1),
                 "%",
                 sep = ""
                 )

pc <- ggplot(my_df, aes(x = nucs))
pc <- pc + geom_histogram(binwidth=0.01, fill = "#DD0A17")
pc <- pc + theme_bw()
pc <- pc + xlim(c(0,1))
pc <- pc + xlab("Cytosine (C, c)")
#pc <- pc + annotate("text", x = 0.95, y=1.5, label= my_text, adj = 1)
my_ymax <- max(ggplot_build(pc)$data[[1]]$y)/2
pc <- pc + annotate("text", x = 0.95, y=my_ymax, label= my_text, adj = 1)
pc <- pc + ylab("Count")

pc
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   




```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("g","G")])/my_nucs$Length)
names(my_df) <- "nucs"
my_med <- median(my_df$nucs)

pug <- sum(my_nucs[,c("G")])/sum(rowSums(my_nucs[,c("g","G")]))

my_text <- paste("Median: ", round(my_med, 3),
                 "\nUppercase: ", round(pug * 100, 1),
                 "%",
                 sep = ""
                 )

pg <- ggplot(my_df, aes(x = nucs))
pg <- pg + geom_histogram(binwidth=0.01, fill = "#1CBE20")
pg <- pg + theme_bw()
pg <- pg + xlim(c(0,1))
pg <- pg + xlab("Guanine (G, g)")
#pg <- pg + annotate("text", x = 0.95, y=1.5, label= my_text, adj = 1)
my_ymax <- max(ggplot_build(pg)$data[[1]]$y)/2
pg <- pg + annotate("text", x = 0.95, y=my_ymax, label= my_text, adj = 1)
pg <- pg + ylab("Count")

pg
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   



```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("t","T")])/my_nucs$Length)
names(my_df) <- "nucs"
my_med <- median(my_df$nucs)

put <- sum(my_nucs[,c("T")])/sum(rowSums(my_nucs[,c("t","T")]))

my_text <- paste("Median: ", round(my_med, 3),
                 "\nUppercase: ", round(put * 100, 1),
                 "%",
                 sep = ""
                 )

pt <- ggplot(my_df, aes(x = nucs))
pt <- pt + geom_histogram(binwidth=0.01, fill = "#E6E431")
pt <- pt + theme_bw()
pt <- pt + xlim(c(0,1))
pt <- pt + xlab("Thymine (T, t)")
#pt <- pt + annotate("text", x = 0.95, y=1.5, label= my_text, adj = 1)
my_ymax <- max(ggplot_build(pt)$data[[1]]$y)/2
pt <- pt + annotate("text", x = 0.95, y=my_ymax, label= my_text, adj = 1)
pt <- pt + ylab("Count")

pt
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("w","W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y")])/my_nucs$Length)
names(my_df) <- "nucs"

pu <- ggplot(my_df, aes(x = nucs))
pu <- pu + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pu <- pu + theme_bw()
pu <- pu + xlim(c(0,1))
# pu <- pu + xlab("IUPAC ambiguous (w,W, s, S, m, M, k, K, r, R, y, Y)")
pu <- pu + xlab("IUPAC ambiguous")
pu <- pu + ylab("Count")
pu <- pu + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pu <- pu + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pu
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   


The ambiguity codes can be looked up on Wikipedia's [nucleotide](https://en.wikipedia.org/wiki/Nucleotide) page.


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("n","N")])/my_nucs$Length)
names(my_df) <- "nucs"

pn <- ggplot(my_df, aes(x = nucs))
pn <- pn + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pn <- pn + theme_bw()
pn <- pn + xlim(c(0,1))
pn <- pn + xlab("Any base (N,n)")
pn <- pn + ylab("Count")
pn <- pn + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pn <- pn + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pn
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   



```{r}
my_df <- as.data.frame(
  my_nucs$Length - 
  rowSums(my_nucs[,c("a", "A", "c", "C", "g", "G", "t", "T", "w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y", "n", "N")])/
  my_nucs$Length)
names(my_df) <- "nucs"

pe <- ggplot(my_df, aes(x = nucs))
pe <- pe + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pe <- pe + theme_bw()
pe <- pe + xlim(c(0,1))
#pe <- pe + xlab("Unexpected characters")
pe <- pe + xlab("Unexpected")
pe <- pe + ylab("Count")
pe <- pe + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pe <- pe + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pe
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   


```{r}
my_df <- data.frame(Length = my_nucs$Length,
                    GC = rowSums(my_nucs[,c("c", "C", "g", "G")])
                    )
my_df$GC <- my_df$GC/my_df$Length
my_df$Length <- my_df$Length/1e6

pgc <- ggplot(my_df, aes(x = GC, y = Length))
pgc <- pgc + geom_point(size = 4, shape = 21, fill = "#B2222299")
pgc <- pgc + theme_bw()
pgc <- pgc + xlim(c(0,1))
# pgc <- pgc + ylab("Length (Kbp)")
pgc <- pgc + ylab("Mbp")
pgc <- pgc + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                   axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                   )
pgc <- pgc + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pgc

my_nucs$Id[my_df$GC < 0.2]
```


We see that most sequences have a similar GC content regardless of length.
One sequence is a bit shorter than all the others and has a GC content of about a half of what the others have.
We've queried the Id above to get the accession number for this sequence.
We can then Google "NC_001224" and select the hit to NCBI and see that this sequence is the
[yeast mitochondrion](https://www.ncbi.nlm.nih.gov/nuccore/NC_001224.1).
It's been my experience that the mitochondrion will tend to have a different GC content than the nuclear sequences.


## Dashboard


For internal purposes we may want a detailed report, as presented above.
If we want to publish this information we may want to summarize this information in a single, multipanel graphic, or dashboard perspective.
This is illustrated below.


```{r, fig.height=8, fig.width=8, fig.cap="**Figure X.** Summary of the genome. Panels **A**, **B**, **C**, and **D** summarize the occurrence of each nucleotide on a per sequence/contig basis. Lowercase characters may indicate that some form of 'masking' may have been implemented. Panel **E** summarizes the length of each sequence/contig, a dashed vertical red line indicates the N50 for the set of sequences/contigs. Panel **F** summarizes the number of positions where [IUPAC ambiguity codes](https://en.wikipedia.org/wiki/Nucleic_acid_sequence#Notation) occured (excluding A, a, C, c, G, g, T, t, N, and n). Panel **G** summarizes the occurence of 'any nucleotide' (N, n) in each sequence/contig. Panel **H** summarizes the occurence of unexpected characters in the sequences, and is expected to be zero. Panel **I** presents the relationship between the length of each sequence/contig and it's G/C content."}
library(ggpubr)

ggarrange(
  ggarrange(pa, pc, pt, pg, ncol = 2, nrow = 2, labels = c("A", "B", "C", "D")),
  pl,
  ggarrange(pu, pn, pe, pgc, ncol = 4, nrow = 1, 
            labels = c("F", "G", "H", "I"),  
            font.label = list(size = 10, color = "black", face = "bold", family = NULL)),
  ncol = 1, nrow = 3,
  labels = c("", "E", ""),
  heights = c(2.5, 2, 1))


# ggsave(filename = paste(my_out, ".png", sep = ""), device = "png",
#        width = 6.5, height = 6.5, units = "in")
# ggsave(filename = paste(my_out, ".tiff", sep = ""), device = "tiff",
#        width = 6.5, height = 6.5, units = "in", compression = "lzw")
```


For the purpose of publication we may desire to save this "dashboard" as a graphic.
After the above code has been run, the ```ggsave()``` function can be uncommented and run.
You'll want to include a meaningful filename.
This will save the dashboard as a ```*.png``` or ```*.tiff``` graphic.


```{r}

genome_df <- data.frame(matrix(
  c("Total length (bp)", sum(my_nucs$Length),
  "Total A,a,C,c,G,g,T,t (bp)", sum(colSums(my_nucs[, c("A", "a", "C", "c", "G", "g", "T", "t")])),
  "Total C,c,G,g (bp)", sum(colSums(my_nucs[, c("C", "c", "G", "g")])),
  "GC/ACGT", sum(colSums(my_nucs[, c("C", "c", "G", "g")]))/sum(colSums(my_nucs[, c("A", "a", "C", "c", "G", "g", "T", "t")])) * 1e2,
  "GC/Total length", sum(colSums(my_nucs[, c("C", "c", "G", "g")]))/sum(my_nucs$Length) * 1e2,
  "N50", n50,
  "N sequences", nrow(my_nucs)), ncol = 2, byrow = TRUE
))
names(genome_df) <- c("Category", "Value")
genome_df$Value <- as.numeric(genome_df$Value)
knitr::kable(genome_df, digits = 3, caption = "**Table X** Summary statistics presented in a manner so that they can be copied into other documents.")

```



## Session information


After performing the above operations we may wish to benchmark the execution time in order to determine how feasible it is to repeat this analysis.
This has been facilitated above by taking time stamps with the function ```Sys.time()```.
We can now use these timestamps to evaluate total execution time.


```{r}
st4 <- Sys.time()
st4 - st1
```


Lastly, we can use the ```sessionInfo()``` function to report the version of ```R()``` we are using as well as the packages and their versions.
This is important information to include if we want to report an issue.


```{r}
sessionInfo()
```

