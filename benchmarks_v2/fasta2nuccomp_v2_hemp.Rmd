---
title: "fasta2nuccomp"
author: "Insert authors here"
date: "`r format(Sys.time(), '%Y, %B %d')`"
output:
  html_document:
    toc: true
    code_folding: hide
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.align = "center")
knitr::opts_chunk$set(fig.height = 4)
knitr::opts_chunk$set(fig.width = 4)
#library(reticulate)
#use_python("/usr/bin/python3")
#use_python("/usr/bin/env python3")
st1 <- Sys.time()
```


## User inputs


```{r}
my_fasta2nuccomp <- "~/gits/fasta2nuccomp/fasta2nuccomp.py"
my_motif_counter <- "~/gits/fasta2nuccomp/motif_counter.py"
# The "L" suppresses scientific notation.
# Scientific notation doesn't pass well to python.
#window_size <- 100000L
#window_size <- 1e5
window_size <- 1e6
```


```{r}
# Arabidopsis
#my_infile <- "GCF_000001735.4_TAIR10.1_genomic.fna.gz"
# Hazelnut
# my_infile <- "GCA_901000735.2_CavTom2PMs-1.0_genomic.fna.gz"
# Potato
# my_infile <- "GCF_000226075.1_SolTub_3.0_genomic.fna.gz"
# Rice
# my_infile <- "GCF_001433935.1_IRGSP-1.0_genomic.fna.gz"
# Mint
# my_infile <- "GCA_001642375.2_Mlong_CMEN585_v3_genomic.fna.gz"
# Populus
# my_infile <- "GCF_000002775.5_P.trichocarpa_v4.1_genomic.fna.gz"
# Hemp
# 
my_infile <- "GCF_900626175.2_cs10_genomic.fna.gz"

# Yeast
#my_infile <- "S288C_reference_sequence_R64-2-1_20150113.fsa.gz"

```




## Three way to implement

- Command line python
- Copy and paste code chunks
- Compile/knit RMarkdown document


- Dependencies
- Implementation
  - python scripts
  - copy and paste R chunks
  - compile/knit RMarkdown



## Overview

- Manage dependencies, validate that example data executes properly
- Run sequence_comp.py
- Run motif_counter.py
- Compile RMarkdown using results from sequence_comp.py and motif_counter.py


The repository ```fasta2nuccomp``` includes tools to help investigators rapidly summarize the contents of a file in the FASTA format.
The python script ```fasta2nuccomp.py``` can be run independently or called from Rmarkdown, as we will see in this document.


## Dependencies


The script ```fasta2nuccomp.py``` was written in python 3.7.3 and biopython 1.78.
You'll want versions that are greater or equal to these versions.
Below we see how to query the versions we have.


If you are presented with the below error then you probably do not have BioPython installed.
Please query your favorite web browser for 'install biopython' or perhaps 'conda install biopython' if you are using a flavor of conda (e.g., miniconda, anaconda, etc.).

```
Traceback (most recent call last):
  File "./fasta2nuccomp.py", line 6, in <module>
    from Bio import SeqIO
ModuleNotFoundError: No module named 'Bio'
```


If you are using conda you may want to include something like the following in your `~/.Rprofile` in order to help RMarkdown find your desired version of python.


```
Sys.setenv(RETICULATE_PYTHON = "~/miniconda3/envs/biopython/bin/python")
```


From an ```R``` prompt we can query which version of ```python``` we are using.


```{r system_python}
my_python <- system("python3 -V", intern = TRUE)
my_python
```


From an interactive ```python``` prompt we can query which version of Biopython we have installed, as follows.


```{r include=FALSE}
options(prompt = '>>> ')
```


```{python biopython_check, prompt=FALSE, eval=FALSE}
import Bio
print(Bio.__version__)
```


```{r include=FALSE}
options(prompt = '> ')
```


Note that these options have been set as 'eval=FALSE' in the RMarkdown chunk options.
This is in order to allow this document to be compiled on systems where these resources are unavailable.
If your system does have these resources available it might be nice for you to set these to be executed as a validation that these resources are actually available.


We'll also want at least R 4.0.2.
You should see the version you have when you start R.
We'll also see how to get this information in the section 'Session information.'
You do not need RStudio, but it is recommended.


## FAST[AQ] files

Nucleotide data is typically stored in a FASTA format file.
This is a text file with a specific format.
A description line begins with '>' and is followed by one or more lines of sequence.
You can learn more about the FASTA format at Wikipedia's [FASTA format](https://en.wikipedia.org/wiki/FASTA_format) page.
The yeast (*Saccharomyces cerevisiae*) strain S288C genome is included with ```fasta2nuccomp``` as an example FASTA file.
Below is a brief example of this file.
Note that the sequence portion of each record may exist on a single line or may be spread over many lines.
Because the sequence portion may be spread over many lines it is recommended that applications that are specifically designed to handle FAST files be used as opposed to treating these files as simple text.


```
>ref|NC_001133| [org=Saccharomyces cerevisiae]
CCACACCACACCCACACACCCACACACCACACCACACACCACACCACACCCACACACACA
CATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTGGCCAACCTGTCTCTCAACTT
>ref|NC_001134| [org=Saccharomyces cerevisiae]
AAATAGCCCTCATGTACGTCTCCTCCAAGCCCTGTTGTCTCTTACCCGGATGTTCAACCA
AAAGCTACTTACTACCTTTATTTTATGTTTACTTTTTATAGGTTGTCTTTTTATCCCACT
```

While sequence_comp.py was developed to process FASTA files containing genomic assemblies, it can also be used to process FASTQ files.
For example, we use this script to summarize sequencing results received from a sequencing center and prior to assembly.
This provides the opportunity to determine the read count and sequence length distribution in these sequencing libraries prior to assembly efforts.
The execution time for sequence_comp.py scale with file size, so processing sequencing libraries should take longer than processing assemblies, but our experience indicates this to be feasible.
Below is an example of a FASTQ file, more information can be found on Wikipedia's [FASTQ](https://en.wikipedia.org/wiki/FASTQ_format) page.
In the FASTQ format there are two description lines, prefixed with '@' on the first line and then '+' on the third line.
The sequence is on the second line, and the quality string is on the fourth line.


```
@SRR10238608.1 1 length=22221
AAATTGATGATTGGCCATTTTGTTTTCTAGAAGGTGCAACTGATCAGGATGAGGCTAGAGCTATTGTCTGATTGCTATAG
+SRR10238608.1 1 length=22221
Y{|e~mRfmVF_K~]~nF}|tjI}mgjutjIr:panhEkdpntsZmLp`Yj\[~idWgT?HbU>[JjYcnnThijfisvj
@SRR10238608.2 2 length=20840
TTATAAGGGTATTTATGTAAATCCCCTTTATATATTAGTCATAGGGTGTATGAGTTCGTATTAAAGACTATAAATAGACC
+SRR10238608.2 2 length=20840
~~~~~~~~~~~_~~~~~~R~~~|~~~R~~~z~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~e~~~~~~~~X~~~~~~~~
```


## Running sequence_comp.py

The python scripts in this repository may be executed at the shell or through this RMarkdown document.
Execution at the shell with the -h flag, `sequence_comp.py -h`, should provide a help message.
In order to use the output in the compilation of this RMarkdown document the file should copied to the same directory as this RMarkdown file and the file name specified in the section 'Processing sequence_comp.py output'.


In order to run `sequence_comp.py` from R one can copy the code below (and all subsequent chunks) or compile/knit this RMarkdown document.
The code chunk below allows the specification of a FASTA file (text or gzipped).
The filename has any path information and extensions removed to create an output file name.
The output file is then predicted by removing the extension from the input file.
This way we can test for the existence of the output file before executing the script.
This may be helpful if we are exploring different methods of postprocessing the output but do not want to rerun the script for each iteration.
Note that ```fasta2nuccomp.py``` must either be in the user's path or the path to the script must be included below.


```{r, eval=TRUE}
st2 <- Sys.time()

#system("wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/735/GCF_000001735.4_TAIR10.1/GCF_000001735.4_TAIR10.1_genomic.fna.gz")
#my_infile <- "GCF_000001735.4_TAIR10.1_genomic.fna.gz"
#my_infile <- "GCF_000226075.1_SolTub_3.0_genomic.fna.gz"

#system("wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/019/925/245/GCA_019925245.1_MQ-UA-ANU_Oaus-KR_1.0/GCA_019925245.1_MQ-UA-ANU_Oaus-KR_1.0_genomic.fna.gz")
#my_infile <- "GCA_019925245.1_MQ-UA-ANU_Oaus-KR_1.0_genomic.fna.gz"
#my_infile <- "S288C_reference_sequence_R64-2-1_20150113.fsa.gz"
my_out <- basename(my_infile)
my_out <- sub("\\.gz$", "", my_out)
my_out <- sub("\\.fna$", "", my_out)
my_out <- sub("\\.fsa$", "", my_out)
my_out <- sub("\\.fasta$", "", my_out)
# Only run python script if it's outfile does not exist. 
if( !file.exists( paste(my_out, "_nuccomp.csv", sep = "") ) ){
  system(paste("~/gits/fasta2nuccomp/fasta2nuccomp.py", my_infile))
}
```


```{r}
st3 <- Sys.time()
st3-st2
```


This will create a comma delimited text file that has the same name as your FASTA file with the added suffix ```_nuccomp.csv```.


### Processing sequence_comp.py output


Once we have summarized our FASTA data we'll want to present it.
This can be accomplished with summary statistics and graphics.
Here we demonstrate how to summarize this data.


```{r}
my_nucs <- readr::read_csv(paste(my_out, "_nuccomp.csv", sep = ""))

if( nrow(my_nucs) > 10 ){
  max_row <- 10
} else {
  max_row <- nrow(my_nucs)
}
knitr::kable(my_nucs[1:max_row, c(1, 2, 3:10, 23, 24)], format.args = list( big.mark = ","))
```


This FASTA file consists of `r format(sum(my_nucs$Length), big.mark=",")` nucleotides organized in `r format(length(my_nucs$Length), big.mark=",")` chromosomes or contigs.
The longest contig is `r format(max(my_nucs$Length), big.mark=",")` bp and the shortest is `r format(min(my_nucs$Length), big.mark=",")`.
We can visualize this information in a semi-automated manner using histograms.


### N50


The summary statistic N50 has become a popular way to summarize the contiguity of a genome assembly.
If we sum the entire number of nucleotides in an assembly and divide this number by two we get half of the assembly size.
If we then sort the chromosomes or contigs in order of length, from longest to shortest, and walk through these until we reach the point of half of the assembly size we can report the length of the contig that contains this nucleotide.
If this contig is long we may conclude that this is a well assembled genome that approaches chromosomes.
If this contig is short we may conclude that this assembly does not approach chromosomes and may have quality issues.
In R we can calculate N50 as follows.


```{r}
my_lens <- sort(my_nucs$Length, decreasing = TRUE)
my_mid <- sum(my_lens)/2

n50 <- my_lens[cumsum(my_lens) >= my_mid][1]

format(n50, big.mark = ",")
```


## Motifs


```{r}
my_bed <- paste(my_out, "_CG_wins.bed", sep = "")
#my_infile
#my_cmd <- paste("~/gits/hempy/bin/motif_counter.py --win_size 50000", my_infile, sep = "")
#my_cmd <- paste("~/gits/hempy/bin/motif_counter.py --win_size 1000000", my_infile, sep = " ")
#my_cmd <- paste("~/gits/hempy/bin/motif_counter.py --win_size", window_size, my_infile, sep = " ")
my_cmd <- paste("~/gits/fasta2nuccomp/motif_counter.py --win_size", window_size, my_infile, sep = " ")
#my_cmd <- paste(my_cmd, "-v")
#my_cmd <- paste(my_cmd, "--no-invert")
if( !file.exists( my_bed ) ){
  system( my_cmd )
}
```


```{r}
motifs <- read.table(my_bed, sep = "\t", header = FALSE)
my_header <- scan(my_bed, 
                  what = "character", sep = ",", skip = 1, nlines = 1)

my_header <- sub("(^# c\\(|\\))", "", my_header)
my_header <- sub("[[:blank:]]", "", my_header)
colnames(motifs) <- my_header
#motifs[1:3, ]
#nrow(motifs)

```


Limit number of sequences (i.e., chromosomes, scaffolds, contigs, etc.).


```{r}
# nseq <- 10
# nseq <- 15
# nseq <- 17
# 
nseq <- 20

if( nseq > nrow(my_nucs) ){
  nseq <- nrow(my_nucs)
}

my_nucs <- my_nucs[1:nseq, ]
motifs <- motifs[motifs$chrom %in% my_nucs$Id, ]
table(motifs$chrom)

# ggplot2::ggplot( data = motifs, ggplot2::aes( x = blockCount, y = score, color = chrom ) ) + ggplot2::geom_point() + ggplot2::theme_bw() + ggplot2::theme(legend.position = "none")
```


Add chromosome number for plotting.


```{r}
my_nucs$chrom_num <- 1:nseq
motifs$chrom_num <- 0
for( i in 1:nrow(my_nucs) ){
  motifs$chrom_num[ motifs$chrom == my_nucs$Id[i] ] <- my_nucs$chrom_num[i]
}
motifs[1:3, ]
```


Add window color


```{r}
#motifs[1:3, ]
range(motifs$score)
my_col <- round( motifs$score/max(motifs$score) * 99 + 1 )
motifs$wincol <- viridisLite::magma(n=1e2, alpha = 1, begin = 0.3, end = 0.95, direction = -1)[my_col]
motifs[1:3, ]
```



## Visualization


Graphical summaries can be created in R as follows.

Note that the end user may have to adjust the manual placement of text in each plot as well as the binwidth used for the histograms.


```{r}
library(ggplot2)
```


```{r}
my_df <- data.frame(Length = my_nucs$Length,
                    GC = rowSums(my_nucs[,c("c", "C", "g", "G")])
                    )

my_max <- max(my_df$Length)
my_med <- median(my_df$Length)
my_min <- min(my_df$Length)
my_seqs <- length(my_df$Length)
my_nzero <- length(my_df$Length > 0)
my_nna <- length(!is.na(my_df$Length))
my_len <- sum(my_df$Length)

#my_df$GC <- my_df$GC/my_df$Length
#my_denom <- 1e3
my_denom <- 1e6
my_df$Length <- my_df$Length/my_denom


my_text <- paste("Nucleotides:\n", format(my_len, big.mark = ","),
                 "\nN50: ", format(n50, big.mark = ","),
                 "\nN seqs: ", format(my_seqs, big.mark = ","),
                 "\nMax: ", format(my_max, big.mark = ","),
                 "\nMedian: ", format(my_med, big.mark = ","),
                 "\nMin: ", format(my_min, big.mark = ","),
                 sep = ""
                 )
```


```{r}

pl <- ggplot(my_df, aes(x = Length))
#pl <- pl + geom_histogram(binwidth=2e4, fill = "blue")

#pl <- pl + geom_histogram(binwidth = 2e1, fill = "blue")
pl <- pl + geom_histogram( fill = "blue" )
pl <- pl + theme_bw()
pl <- pl + geom_vline(xintercept = n50/my_denom, color = "#B22222",
                      #size = 1.5,
                      linewidth = 1.5,
                      linetype="dashed")
my_ymax <- max(ggplot_build(pl)$data[[1]]$y)/2
#
pl <- pl + annotate("text", x = my_max/my_denom * 0.95, y = my_ymax,
                    label = my_text, adj = 1)

#pl <- pl + xlab("Length (Kbp)")
pl <- pl + xlab("Length (Mbp)")
pl <- pl + ylab("Count")

pl
```


Maximum value: `r format(max(my_nucs$Length), big.mark=",")`;   
median value: `r format(median(my_nucs$Length), big.mark=",")`;   
minimum value: `r format(min(my_nucs$Length), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   



```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("a","A")])/my_nucs$Length)
names(my_df) <- "nucs"
my_df$Base <- "Adenine"
#my_df$Base <- "A"

tmp <- as.data.frame(rowSums(my_nucs[,c("t","T")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Thymine"
#tmp$Base <- "T"
my_df <- rbind(my_df, tmp)

tmp <- as.data.frame(rowSums(my_nucs[,c("c","C")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Cytosine"
#tmp$Base <- "C"
my_df <- rbind(my_df, tmp)

tmp <- as.data.frame(rowSums(my_nucs[,c("g","G")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Guanine"
#tmp$Base <- "G"
my_df <- rbind(my_df, tmp)
#my_df$Base <- factor(my_df$Base, levels = c("A", "T", "G", "C"))
dput(unique(my_df$Base))
my_df$Base <- factor(my_df$Base, levels = c("Adenine", "Cytosine", "Thymine", "Guanine"))
#my_df$Base <- factor(my_df$Base, levels = c("A", "C", "T", "G"))

my_df[1:3, ]

#my_pal <- c("#5157FB", "#DD0A17", "#1CBE20", "#E6E431")
my_pal <- c("#DD0A17", "#5157FB", "#1CBE20", "#E6E431")

pat <- ggplot(my_df, aes(x = nucs, color = Base, fill = Base))
pat <- pat + geom_histogram( binwidth = 0.01 )
#pat
#pat + facet_grid( . ~ Base)
pat <- pat + facet_wrap( . ~ Base, nrow = 2, ncol = 2)
pat <- pat + theme_bw()
#pat <- pat + theme( strip.background = element_rect( fill = "#FFFFFF" ) )
#pat <- pat + theme( strip.background = element_rect( fill = "#D3D3D3" ) )
pat <- pat + theme( strip.background = element_rect( fill = "#F5F5F5" ) )

pat <- pat + xlim( c( 0, 0.5 ) )
pat <- pat + xlab("Base frequency in sequence")
pat <- pat + ylab("Sequence count")
#pat + scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9", "#56B4E9"))
pat <- pat + scale_color_manual(values=c("#FFFFFF00", "#FFFFFF00", "#FFFFFF00", "#FFFFFF00"))

pat <- pat + scale_fill_manual( values = my_pal )
pat <- pat + theme(legend.position = "none")
pat
```





```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("w","W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y")])/my_nucs$Length)
names(my_df) <- "nucs"

pu <- ggplot(my_df, aes(x = nucs))
pu <- pu + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pu <- pu + theme_bw()
pu <- pu + xlim(c(0,1))
# pu <- pu + xlab("IUPAC ambiguous (w,W, s, S, m, M, k, K, r, R, y, Y)")
pu <- pu + xlab("IUPAC ambiguous")
pu <- pu + ylab("Count")
pu <- pu + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pu <- pu + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pu
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   


The ambiguity codes can be looked up on Wikipedia's [nucleotide](https://en.wikipedia.org/wiki/Nucleotide) page.


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("n","N")])/my_nucs$Length)
names(my_df) <- "nucs"

pn <- ggplot(my_df, aes(x = nucs))
pn <- pn + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pn <- pn + theme_bw()
pn <- pn + xlim(c(0,1))
pn <- pn + xlab("Any base (N,n)")
pn <- pn + ylab("Count")
pn <- pn + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pn <- pn + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pn
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   



```{r}
my_df <- as.data.frame(
  my_nucs$Length - 
  rowSums(my_nucs[,c("a", "A", "c", "C", "g", "G", "t", "T", "w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y", "n", "N")])/
  my_nucs$Length)
names(my_df) <- "nucs"

pe <- ggplot(my_df, aes(x = nucs))
pe <- pe + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pe <- pe + theme_bw()
pe <- pe + xlim(c(0,1))
#pe <- pe + xlab("Unexpected characters")
pe <- pe + xlab("Unexpected")
pe <- pe + ylab("Count")
pe <- pe + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pe <- pe + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pe
```


Maximum value: `r format(max(my_df$nucs), big.mark=",")`;   
median value: `r format(median(my_df$nucs), big.mark=",")`;   
minimum value: `r format(min(my_df$nucs), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   


```{r}
my_df <- data.frame(Length = my_nucs$Length,
                    GC = rowSums(my_nucs[,c("c", "C", "g", "G")])
                    )
my_df$GC <- my_df$GC/my_df$Length
my_df$Length <- my_df$Length/1e6

pgc <- ggplot(my_df, aes(x = GC, y = Length))
pgc <- pgc + geom_point(size = 4, shape = 21, fill = "#B2222299")
pgc <- pgc + theme_bw()
pgc <- pgc + xlim(c(0,1))
# pgc <- pgc + ylab("Length (Kbp)")
pgc <- pgc + ylab("Mbp")
pgc <- pgc + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                   axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                   )
pgc <- pgc + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pgc

my_nucs$Id[my_df$GC < 0.2]
```


We see that most sequences have a similar GC content regardless of length.
One sequence is a bit shorter than all the others and has a GC content of about a half of what the others have.
We've queried the Id above to get the accession number for this sequence.
We can then Google "NC_001224" and select the hit to NCBI and see that this sequence is the
[yeast mitochondrion](https://www.ncbi.nlm.nih.gov/nuccore/NC_001224.1).
It's been my experience that the mitochondrion will tend to have a different GC content than the nuclear sequences.


### Ideogram


```{r}
library(ggplot2)
chrom_wid <- 0.1

# Initialize empty plot.
p <- ggplot( )

# Add chromosomes.
p <- p + geom_rect( 
  data = my_nucs, 
  aes( xmin = chrom_num - chrom_wid,
       xmax = chrom_num + chrom_wid,
       ymin = 1, ymax = Length),
  fill = "#DCDCDC",
  color = "#000000"
)

# Theme options.
p <- p + theme_bw()
p <- p + scale_x_continuous( 
  breaks = my_nucs$chrom_num,
  labels = my_nucs$Id
)
#p

#yunits <- 1e3
#yunits <- 1e7

# yunits <- 1e6
# my_ymax <- ceiling(max(my_nucs$Length)/yunits) * yunits
# p <- p + scale_y_continuous(
#   breaks = seq( 0, my_ymax, by = yunits ),
#   labels = seq( 0, my_ymax, by = yunits)/yunits,
# )


if( max(my_nucs$Length) > 1e7 ){
  yunits <- 1e7
  my_ymax <- ceiling(max(my_nucs$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits * 10,
  )
} else if( max(my_nucs$Length) > 1e6 ){
  yunits <- 1e6
  my_ymax <- ceiling(max(my_nucs$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits,
  )
} else if( max(my_nucs$Length) > 1e5 ){
  yunits <- 1e5
  my_ymax <- ceiling(max(my_nucs$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits * 0.1,
  )
}



#  breaks = seq( 0, my_ymax, by = yunits * 1e2),
#  labels = seq( 0, my_ymax/1e3, by = 1e2),
#  breaks = seq( 0, my_ymax, by = yunits * 2e-1),
#  labels = seq( 0, my_ymax/yunits, by = 2e-1),
#)
#p <- p + ggplot2::ylab("Position (Kbp)")
p <- p + ggplot2::ylab("Position (Mbp)")

#p
p <- p + ggplot2::theme( 
    panel.grid.minor.x = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 3 ),
    axis.text.x = element_text(angle = 60, hjust = 1),
    axis.title.x=element_blank(),
    panel.grid.major.y = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 1 ),
    panel.grid.minor.y = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 3 )
  )
#p
#p <- p + ggtitle( "My sequences" )
#
```


```{r, fig.width=10}
p

# Uncomment here, and comment the 'motif windows' section below to include ideogram instead of windows graphics.
# 
pwin <- p
```


### Motif windows

```{r}
library(ggplot2)
motifs[1:3, ]
#motifs$wincol
# Initialize empty plot.
#p <- ggplot( )

# Add windows.
p <- p + geom_rect( 
  data = motifs, 
  aes( xmin = chrom_num - score/1e3 * 0.4,
      xmax = chrom_num + score/1e3 * 0.4,
       ymin = chromStart, ymax = chromEnd),
#  fill = "#DCDCDC",
  fill = motifs$wincol,
#  color = "#000000"
  color = "#00000055"
)

# Theme options.
# p <- p + theme_bw()
# p <- p + scale_x_continuous( 
#   breaks = my_nucs$chrom_num,
#   labels = my_nucs$Id
# )
#p

#yunits <- 1e3
# yunits <- 1e6
# my_ymax <- ceiling(max(my_nucs$Length)/yunits) * yunits
# p <- p + scale_y_continuous(
# #  breaks = seq( 0, my_ymax, by = yunits * 1e2),
# #  labels = seq( 0, my_ymax/1e3, by = 1e2),
# #  breaks = seq( 0, my_ymax, by = yunits * 1e-0),
# #  labels = seq( 0, my_ymax/yunits, by = 1e-0),
#   breaks = seq( 0, my_ymax, by = yunits * 5e-1),
#   labels = seq( 0, my_ymax/yunits, by = 5e-1),
# )
# #p <- p + ggplot2::ylab("Position (Kbp)")
# p <- p + ggplot2::ylab("Position (Mbp)")

#p
# p <- p + ggplot2::theme( 
#     panel.grid.minor.x = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 3 ),
#     axis.text.x = element_text(angle = 60, hjust = 1),
#     axis.title.x=element_blank(),
#     panel.grid.major.y = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 1 ),
#     panel.grid.minor.y = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 3 )
#   )
# #p
# #
# #p <- p + ggplot2::ylab("Position (Kbp)")
# p <- p + ggplot2::ylab("Position (Mbp)")
#p <- p + ggtitle( "My sequences" )
```


```{r, fig.width=10}
p
# Uncomment to include window graphic instead of ideogram (above).
# 
pwin <- p

```





## Dashboard


For internal purposes we may want a detailed report, as presented above.
If we want to publish this information we may want to summarize this information in a single, multipanel graphic, or dashboard perspective.
This is illustrated below.


```{r, fig.height=8, fig.width=8, fig.cap="**Figure X.** Summary of the genome. Panels **A**, **B**, **C**, and **D** summarize the occurrence of each nucleotide on a per sequence/contig basis. Lowercase characters may indicate that some form of 'masking' may have been implemented. Panel **E** summarizes the length of each sequence/contig, a dashed vertical red line indicates the N50 for the set of sequences/contigs. Panel **F** summarizes the number of positions where [IUPAC ambiguity codes](https://en.wikipedia.org/wiki/Nucleic_acid_sequence#Notation) occured (excluding A, a, C, c, G, g, T, t, N, and n). Panel **G** summarizes the occurence of 'any nucleotide' (N, n) in each sequence/contig. Panel **H** summarizes the occurence of unexpected characters in the sequences, and is expected to be zero. Panel **I** presents the relationship between the length of each sequence/contig and it's G/C content."}
library(ggpubr)

# ggarrange(pl, pat,
#           ncol = 2, nrow = 1,
#           labels = c("A", "B"),
#           widths = c(1, 1.2)
# )

# pwin

# ggarrange(pu, pn, pe, pgc, ncol = 4, nrow = 1, 
#             labels = c("F", "G", "H", "I"),  
#             font.label = list(size = 10, color = "black", face = "bold", family = NULL))


ggarrange(
  ggarrange(pl, pat,
          ncol = 2, nrow = 1,
          labels = c("A", "B"),
          widths = c(1, 1.2)
  ),
  pwin,
  ggarrange(pu, pn, pe, pgc, ncol = 4, nrow = 1, 
            labels = c("D", "E", "F", "G"),  
            font.label = list(size = 10, color = "black", face = "bold", family = NULL)),
  ncol = 1, nrow = 3,
  labels = c("", "C", ""),
  heights = c(2.0, 2.5, 1)
)


# ggsave(filename = paste(my_out, ".png", sep = ""), device = "png",
#        width = 6.5, height = 6.5, units = "in")
# ggsave(filename = paste(my_out, ".tiff", sep = ""), device = "tiff",
#        width = 6.5, height = 6.5, units = "in", compression = "lzw")
```


## Tabular output


For the purpose of publication we may desire to save this "dashboard" as a graphic.
After the above code has been run, the ```ggsave()``` function can be uncommented and run.
You'll want to include a meaningful filename.
This will save the dashboard as a ```*.png``` or ```*.tiff``` graphic.


```{r}
genome_df <- data.frame(matrix(
  c(
    "Total length (bp)", sum(my_nucs$Length),
    "Number of sequences (count)", nrow(my_nucs),
    "N50 (bp)", n50,
    "Median length (bp)", median(my_nucs$Length),
    "Maximun length (bp)", max(my_nucs$Length),
    "Tenth longest sequence (bp)", sort(my_nucs$Length, decreasing = TRUE)[10],
    "Total A,a,C,c,G,g,T,t (bp)", sum(colSums(my_nucs[, c("A", "a", "C", "c", "G", "g", "T", "t")])),
    "Total C,c,G,g (bp)", sum(colSums(my_nucs[, c("C", "c", "G", "g")])),
    "GC/ACGT (percentage)", sum(colSums(my_nucs[, c("C", "c", "G", "g")]))/sum(colSums(my_nucs[, c("A", "a", "C", "c", "G", "g", "T", "t")])) * 1e2,
    "GC/Total length (percentage)", sum(colSums(my_nucs[, c("C", "c", "G", "g")]))/sum(my_nucs$Length) * 1e2
  ),
  ncol = 2, byrow = TRUE
))
genome_df <- as.data.frame(genome_df)
names(genome_df) <- c("Category", "Value")
genome_df$Value <- as.numeric(genome_df$Value)

proc_time <- Sys.time() - st1
genome_df <- rbind(genome_df, c("Processing time", format( proc_time, units = "mins")))

knitr::kable(genome_df, 
             digits = 3, 
             format.args = list(scientific = FALSE, big.mark = ","),
             caption = "**Table X** Summary of the sequences.")
```


```{r, comment=NA}
# 
genome_df <- t(genome_df)
colnames( genome_df ) <- genome_df[1, ]
genome_df <- genome_df[-1, , drop = FALSE]
#
dput(genome_df)
# write.table( x = t(genome_df), file = "fasta2nuccomp_summary.csv",
#              sep = ",", row.names = FALSE, col.names = FALSE )
```



## Session information


After performing the above operations we may wish to benchmark the execution time in order to determine how feasible it is to repeat this analysis.
This has been facilitated above by taking time stamps with the function ```Sys.time()```.
We can now use these timestamps to evaluate total execution time.


```{r}
st4 <- Sys.time()
st4 - st1
```


Lastly, we can use the ```sessionInfo()``` function to report the version of ```R()``` we are using as well as the packages and their versions.
This is important information to include if we want to report an issue.


```{r}
sessionInfo()
```

