---
title: "fasta2nuccomp"
author: "Insert authors here"
date: "`r format(Sys.time(), '%Y, %B %d')`"
output:
  html_document:
    toc: true
    code_folding: show
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
#
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.align = "center")
knitr::opts_chunk$set(fig.height = 4)
knitr::opts_chunk$set(fig.width = 4)
#library(reticulate)
#use_python("/usr/bin/python3")
#use_python("/usr/bin/env python3")
st1 <- Sys.time()
```


## User inputs

The user should provide the paths to the python scripts in this repository.
They can also specify a window size.
Windows of 1 Mbp tend to work well for chromosomes (sequences) around 10 - 100 Mbp.
Window size is parameterizable so that investigators can explore values they feel may be appropriate.


```{r}
my_fasta2nuccomp <- "~/gits/fasta2nuccomp/fasta2nuccomp.py"
my_motif_counter <- "~/gits/fasta2nuccomp/motif_counter.py"
# The "L" suppresses scientific notation.
# Scientific notation doesn't pass well to python.
#window_size <- 100000L
#
window_size <- 1e5
# window_size <- 1e6
# Sort the sequences by decreasing size.
size_sort <- FALSE
#size_sort <- TRUE
clean_filess <- FALSE
#clean_filess <- TRUE
```


Here we specify the FAST[AQ] format input file.
The FAST[AQ] extension, and possible gzip extension, are removed to create a base name in both python scripts.
This basename is used to create output files \*_nuccomp.csv and \*_wins.bed.
For example, the FASTA input file "GCF_900626175.2_cs10_genomic.fna.gz" will be processed into the output files "GCF_900626175.2_cs10_genomic_nuccomp.csv" and "GCF_900626175.2_cs10_genomic_CG_wins.bed", where 'CG' was the queried motif.
If these files have already been generated (e.g., the python scripts were run independently), they can be placed in the directory where this RMarkdown is compiled and they should be found by the script, avoid the need to call the python scripts.


```{r}
# Arabidopsis
# my_infile <- "GCF_000001735.4_TAIR10.1_genomic.fna.gz"
# Cottonwood
# my_infile <- "GCF_000002775.5_P.trichocarpa_v4.1_genomic.fna.gz"
# Hazelnut
# my_infile <- "GCA_901000735.2_CavTom2PMs-1.0_genomic.fna.gz"
# Hemp
# my_infile <- "GCF_900626175.2_cs10_genomic.fna.gz"
# Mint
# my_infile <- "GCA_001642375.2_Mlong_CMEN585_v3_genomic.fna.gz"
# Potato
#
my_infile <- "GCF_000226075.1_SolTub_3.0_genomic.fna.gz"
# Rice
# my_infile <- "GCF_001433935.1_IRGSP-1.0_genomic.fna.gz"
# Yeast
#my_infile <- "S288C_reference_sequence_R64-2-1_20150113.fsa.gz"
```


```{r}
my_out <- basename(my_infile)
my_out <- sub("\\.gz$", "", my_out)
my_out <- sub("\\.fna$", "", my_out)
my_out <- sub("\\.fsa$", "", my_out)
my_out <- sub("\\.fasta$", "", my_out)
```


```{r}
if( clean_filess == TRUE ){
  unlink( paste(my_out, "_nuccomp.csv", sep = "") )
  unlink( paste(my_out, "_CG_wins.bed", sep = "") )
}
```


## Dependencies


The script ```fasta2nuccomp.py``` was written in python 3.7.3 and biopython 1.78.
You'll want versions that are greater or equal to these versions.
Below we see how to query the versions we have.


If you are presented with the below error then you probably do not have BioPython installed.
Please query your favorite web browser for 'install biopython' or perhaps 'conda install biopython' if you are using a flavor of conda (e.g., miniconda, anaconda, etc.).

```
Traceback (most recent call last):
  File "./fasta2nuccomp.py", line 6, in <module>
    from Bio import SeqIO
ModuleNotFoundError: No module named 'Bio'
```


If you are using conda you may want to include something like the following in your `~/.Rprofile` in order to help RMarkdown find your desired version of python.


```
Sys.setenv(RETICULATE_PYTHON = "~/miniconda3/envs/biopython/bin/python")
```


From an ```R``` prompt we can query which version of ```python``` we are using.


```{r system_python}
my_python <- system("python3 -V", intern = TRUE)
my_python
```


We'll also want at least R 4.0.2.
You should see the version you have when you start R.
We'll also see how to get this information in the section 'Session information.'
You do not need RStudio, but it is recommended.


## FAST[AQ] files

Nucleotide data is typically stored in a FASTA format file.
This is a text file with a specific format.
A description line begins with '>' and is followed by one or more lines of sequence.
You can learn more about the FASTA format at Wikipedia's [FASTA format](https://en.wikipedia.org/wiki/FASTA_format) page.
The yeast (*Saccharomyces cerevisiae*) strain S288C genome is included with ```fasta2nuccomp``` as an example FASTA file.
Below is a brief example of this file.
Note that the sequence portion of each record may exist on a single line or may be spread over many lines.
Because the sequence portion may be spread over many lines it is recommended that applications that are specifically designed to handle FAST files be used as opposed to treating these files as simple text.


```
>ref|NC_001133| [org=Saccharomyces cerevisiae]
CCACACCACACCCACACACCCACACACCACACCACACACCACACCACACCCACACACACA
CATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTGGCCAACCTGTCTCTCAACTT
>ref|NC_001134| [org=Saccharomyces cerevisiae]
AAATAGCCCTCATGTACGTCTCCTCCAAGCCCTGTTGTCTCTTACCCGGATGTTCAACCA
AAAGCTACTTACTACCTTTATTTTATGTTTACTTTTTATAGGTTGTCTTTTTATCCCACT
```

While sequence_comp.py was developed to process FASTA files containing genomic assemblies, it can also be used to process FASTQ files.
For example, we use this script to summarize sequencing results received from a sequencing center and prior to assembly.
This provides the opportunity to determine the read count and sequence length distribution in these sequencing libraries prior to assembly efforts.
The execution time for sequence_comp.py scale with file size, so processing sequencing libraries should take longer than processing assemblies, but our experience indicates this to be feasible.
Below is an example of a FASTQ file, more information can be found on Wikipedia's [FASTQ](https://en.wikipedia.org/wiki/FASTQ_format) page.
In the FASTQ format there are two description lines, prefixed with '@' on the first line and then '+' on the third line.
The sequence is on the second line, and the quality string is on the fourth line.


```
@SRR10238608.1 1 length=22221
AAATTGATGATTGGCCATTTTGTTTTCTAGAAGGTGCAACTGATCAGGATGAGGCTAGAGCTATTGTCTGATTGCTATAG
+SRR10238608.1 1 length=22221
Y{|e~mRfmVF_K~]~nF}|tjI}mgjutjIr:panhEkdpntsZmLp`Yj\[~idWgT?HbU>[JjYcnnThijfisvj
@SRR10238608.2 2 length=20840
TTATAAGGGTATTTATGTAAATCCCCTTTATATATTAGTCATAGGGTGTATGAGTTCGTATTAAAGACTATAAATAGACC
+SRR10238608.2 2 length=20840
~~~~~~~~~~~_~~~~~~R~~~|~~~R~~~z~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~e~~~~~~~~X~~~~~~~~
```


## Running sequence_comp.py

The python scripts in this repository may be executed at the shell or through this RMarkdown document.
Execution at the shell with the -h flag, `sequence_comp.py -h`, should provide a help message.
In order to use the output in the compilation of this RMarkdown document the file should copied to the same directory as this RMarkdown file and the file name specified in the section 'Processing sequence_comp.py output'.


In order to run `sequence_comp.py` from R one can copy the code below (and all subsequent chunks) or compile/knit this RMarkdown document.
The code chunk below allows the specification of a FASTA file (text or gzipped).
The filename has any path information and extensions removed to create an output file name.
The output file is then predicted by removing the extension from the input file.
This way we can test for the existence of the output file before executing the script.
This may be helpful if we are exploring different methods of postprocessing the output but do not want to rerun the script for each iteration.
Note that ```fasta2nuccomp.py``` must either be in the user's path or the path to the script must be included below.


```{r, eval=TRUE}
st2 <- Sys.time()

# Only run python script if it's outfile does not exist. 
if( !file.exists( paste(my_out, "_nuccomp.csv", sep = "") ) ){
#  system(paste("~/gits/fasta2nuccomp/fasta2nuccomp.py", my_infile))
  system(paste(my_fasta2nuccomp, my_infile))
}
```


```{r}
st3 <- Sys.time()
st3-st2
```


This will create a comma delimited text file that has the same name as your FASTA file with the added suffix ```_nuccomp.csv```.


### Processing sequence_comp.py output


Once we have summarized our FASTA data we'll want to present it.
This can be accomplished with summary statistics and graphics.
Here we demonstrate how to summarize this data.


```{r}
my_nucs <- readr::read_csv(paste(my_out, "_nuccomp.csv", sep = ""))

if( size_sort == TRUE ){
  my_nucs <- my_nucs[ sort.int(my_nucs$Length, decreasing = TRUE, index.return = TRUE)$ix, ]
}

if( nrow(my_nucs) > 10 ){
  max_row <- 10
} else {
  max_row <- nrow(my_nucs)
}
knitr::kable(my_nucs[1:max_row, c(1, 2, 3:10, 23, 24)], format.args = list( big.mark = ","))
```


This FASTA file consists of `r format(sum(my_nucs$Length), big.mark=",")` nucleotides organized in `r format(length(my_nucs$Length), big.mark=",")` chromosomes or contigs.
The longest contig is `r format(max(my_nucs$Length), big.mark=",")` bp and the shortest is `r format(min(my_nucs$Length), big.mark=",")`.
We can visualize this information in a semi-automated manner using histograms.


### N50


The summary statistic N50 has become a popular way to summarize the contiguity of a genome assembly.
If we sum the entire number of nucleotides in an assembly and divide this number by two we get half of the assembly size.
If we then sort the chromosomes or contigs in order of length, from longest to shortest, and walk through these until we reach the point of half of the assembly size we can report the length of the contig that contains this nucleotide.
If this contig is long we may conclude that this is a well assembled genome that approaches chromosomes.
If this contig is short we may conclude that this assembly does not approach chromosomes and may have quality issues.
In R we can calculate N50 as follows.


```{r}
my_lens <- sort(my_nucs$Length, decreasing = TRUE)
my_mid <- sum(my_lens)/2

n50 <- my_lens[cumsum(my_lens) >= my_mid][1]

format(n50, big.mark = ",")
```


## Run motif_counter.py


The python script `motif_counter.py` takes as input a FASTA of FASTQ file and a motif.
The sequence in this file is divided into non-overlapping windows of user specified length.
Each window is queried for a motif using a regular expression and the count of the matches is reported.
The motif 'CG' has been selected as default because it is associated with methylation and may help identify centromeric regions.
The counts of the motif, a scaled and inverted score, and an RGB code based on the score are reported in a \*.BED format file.
This \*.BED file has embedded comments for header suggestions in R and python.


```{r}
my_bed <- paste(my_out, "_CG_wins.bed", sep = "")
#my_cmd <- paste("~/gits/fasta2nuccomp/motif_counter.py --win_size", window_size, my_infile, sep = " ")
my_cmd <- paste( my_motif_counter, "--win_size", window_size, my_infile, sep = " ")
#my_cmd <- paste(my_cmd, "-v")
#my_cmd <- paste(my_cmd, "--no-invert")
if( !file.exists( my_bed ) ){
  system( my_cmd )
}
```


### Processing results from motif_counter.py


Results from `motif_counter.py` are presented in a *.BED format file.
More information on the BED format can be found at the [UCSC BED file format FAQ](https://genome.ucsc.edu/FAQ/FAQformat.html#format1) and at Wikipedia's [BED format page](https://en.wikipedia.org/wiki/BED_(file_format)).
A BED file can be seen as tabular data that minimally includes a chromosome, start, and end coordinates.
The BED file produced by `motif_counter.py` includes 'blockCount', the motif count for the window, 'blockSizes' for each window (the last window for each sequence should be smaller than the others), and 'score' which is 1 minus the blockCount divided by blockSizes and multiplied by 1000 to range from 0 - 1000, as specified by the format.
There is also 'itemRGB' which is based on the score.
Below is an example of how to read this file into R and use the header suggestion.


```{r}
motifs <- read.table(my_bed, sep = "\t", header = FALSE)
my_header <- scan(my_bed, 
                  what = "character", sep = ",", skip = 1, nlines = 1)
my_header <- sub("(^# c\\(|\\))", "", my_header)
my_header <- sub("[[:blank:]]", "", my_header)
colnames(motifs) <- my_header
#motifs[1:3, ]
#nrow(motifs)
knitr::kable(motifs[1:5, ])
```


The BED file includes a 'chrom' column, which is typically a string.
For plotting purposes it's frequently convenient to have a numerical representation for each chromosome.
Here we use the order reported in the nuccomp output to assign chromosome numbers and add these to the motif_counter data.


```{r}
my_nucs$chrom_num <- 1:nrow(my_nucs)
motifs$chrom_num <- 0
for( i in 1:nrow(my_nucs) ){
  motifs$chrom_num[ motifs$chrom == my_nucs$Id[i] ] <- my_nucs$chrom_num[i]
}
#motifs[1:3, ]
```


The BED file includes 'itemRGB' which can be converted to hexadecimal for plotting in R.


```{r}
#motifs[1:3, ]
motifs$wincol <- unlist(lapply(strsplit(motifs$itemRGB, split = ","), function(x){ rgb(red = x[1], green = x[2], blue = x[3], maxColorValue = 255) }))
# range(motifs$score)
# my_col <- round( motifs$score/max(motifs$score) * 99 + 1 )
# motifs$wincol <- viridisLite::magma(n=1e2, alpha = 1, begin = 0.3, end = 0.95, direction = -1)[my_col]
#motifs[1:3, ]
knitr::kable(motifs[1:5, ])
```



## Visualization


Graphical summaries can be created in R as follows.
Note that the end user may have to adjust the manual placement of text in each plot as well as the binwidth used for the histograms.


```{r}
my_df <- data.frame(Length = my_nucs$Length,
                    GC = rowSums(my_nucs[,c("c", "C", "g", "G")])
                    )

my_max <- max(my_df$Length)
my_med <- median(my_df$Length)
my_min <- min(my_df$Length)
my_seqs <- length(my_df$Length)
my_nzero <- length(my_df$Length > 0)
my_nna <- length(!is.na(my_df$Length))
my_len <- sum(my_df$Length)

#my_df$GC <- my_df$GC/my_df$Length
#my_denom <- 1e3
my_denom <- 1e6
my_df$Length <- my_df$Length/my_denom


my_text <- paste("Nucleotides:\n", format(my_len, big.mark = ","),
                 "\nN50: ", format(n50, big.mark = ","),
                 "\nN seqs: ", format(my_seqs, big.mark = ","),
                 "\nMax: ", format(my_max, big.mark = ","),
                 "\nMedian: ", format(my_med, big.mark = ","),
                 "\nMin: ", format(my_min, big.mark = ","),
                 sep = ""
                 )
```


```{r}
library(ggplot2)
pl <- ggplot(my_df, aes(x = Length))
#pl <- pl + geom_histogram(binwidth=2e4, fill = "blue")

#pl <- pl + geom_histogram(binwidth = 2e1, fill = "blue")
#pl <- pl + geom_histogram( fill = "blue", binwidth = 1 )
pl <- pl + geom_histogram( fill = "blue", bins = 30 )
pl <- pl + theme_bw()
pl <- pl + geom_vline(xintercept = n50/my_denom, color = "#B22222",
                      #size = 1.5,
                      linewidth = 1.5,
                      linetype="dashed")
my_ymax <- max(ggplot_build(pl)$data[[1]]$y)/2
#
pl <- pl + annotate("text", x = my_max/my_denom * 0.95, y = my_ymax,
                    label = my_text, adj = 1)

#pl <- pl + xlab("Length (Kbp)")
pl <- pl + xlab("Length (Mbp)")
pl <- pl + ylab("Count")

pl
```


Maximum value: `r format(max(my_nucs$Length), big.mark=",")`;   
median value: `r format(median(my_nucs$Length), big.mark=",")`;   
minimum value: `r format(min(my_nucs$Length), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   



```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("a","A")])/my_nucs$Length)
names(my_df) <- "nucs"
my_df$Base <- "Adenine"
#my_df$Base <- "A"

tmp <- as.data.frame(rowSums(my_nucs[,c("t","T")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Thymine"
#tmp$Base <- "T"
my_df <- rbind(my_df, tmp)

tmp <- as.data.frame(rowSums(my_nucs[,c("c","C")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Cytosine"
#tmp$Base <- "C"
my_df <- rbind(my_df, tmp)

tmp <- as.data.frame(rowSums(my_nucs[,c("g","G")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Guanine"
#tmp$Base <- "G"
my_df <- rbind(my_df, tmp)
#my_df$Base <- factor(my_df$Base, levels = c("A", "T", "G", "C"))
#dput(unique(my_df$Base))
my_df$Base <- factor(my_df$Base, levels = c("Adenine", "Cytosine", "Thymine", "Guanine"))
#my_df$Base <- factor(my_df$Base, levels = c("A", "C", "T", "G"))

my_df <- my_df[!is.na(my_df$nucs), , drop = FALSE]

#my_df[1:3, ]

#my_pal <- c("#5157FB", "#DD0A17", "#1CBE20", "#E6E431")
my_pal <- c("#DD0A17", "#5157FB", "#1CBE20", "#E6E431")

pat <- ggplot(my_df, aes(x = nucs, color = Base, fill = Base))
#pat <- pat + geom_histogram( binwidth = 0.01 )
pat <- pat + geom_histogram( bins = 30 )
#pat
#pat + facet_grid( . ~ Base)
pat <- pat + facet_wrap( . ~ Base, nrow = 2, ncol = 2)
pat <- pat + theme_bw()
#pat <- pat + theme( strip.background = element_rect( fill = "#FFFFFF" ) )
#pat <- pat + theme( strip.background = element_rect( fill = "#D3D3D3" ) )
pat <- pat + theme( strip.background = element_rect( fill = "#F5F5F5" ) )

#pat <- pat + xlim( c( 0, 0.5 ) )
pat <- pat + xlab("Base frequency in sequence")
pat <- pat + ylab("Sequence count")
#pat + scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9", "#56B4E9"))
pat <- pat + scale_color_manual(values=c("#FFFFFF00", "#FFFFFF00", "#FFFFFF00", "#FFFFFF00"))

pat <- pat + scale_fill_manual( values = my_pal )
pat <- pat + theme(legend.position = "none")
pat
```





```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("w","W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y")])/my_nucs$Length)
names(my_df) <- "nucs"
my_df <- my_df[ !is.na(my_df$nucs), , drop = FALSE ]
my_df <- my_df[ my_df$nucs > 0, , drop = FALSE ]
#my_df[1:3, , drop = FALSE]
#head(my_df)

pu <- ggplot(my_df, aes(x = nucs))
#pu <- pu + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pu <- pu + geom_histogram(bins=30, fill = "#AD26FA")
pu <- pu + theme_bw()
pu <- pu + xlim(c(0,1))
# pu <- pu + xlab("IUPAC ambiguous (w,W, s, S, m, M, k, K, r, R, y, Y)")
pu <- pu + xlab("IUPAC ambiguous")
pu <- pu + ylab("Count")
pu <- pu + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pu <- pu + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pu
```



```{r}
my_df <- data.frame( nucs = rowSums(my_nucs[,c("w","W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y")]))
report <- data.frame(
  row.names = c("Maximum", "Median", "Minimum", "Number", "Number0", "Number!NA")
)
report$Value <- 0
report

if( nrow(my_df) > 0 ){
  report$Value[ 1 ] <-  max(my_df$nucs, na.rm = TRUE)
  report$Value[ 2 ] <-  median(my_df$nucs, na.rm = TRUE)
  report$Value[ 3 ] <-  min(my_df$nucs, na.rm = TRUE)
  report$Value[ 4 ] <-  length(my_df$nucs)
  report$Value[ 5 ] <-  sum(my_df$nucs > 0)
  report$Value[ 6 ] <-  length(!is.na(my_df$nucs))
}
knitr::kable(report)
```



The IUPAC ambiguity codes can be looked up on Wikipedia's [nucleotide](https://en.wikipedia.org/wiki/Nucleotide) page.


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("n","N")])/my_nucs$Length)
names(my_df) <- "nucs"
my_df <- my_df[!is.na(my_df$nucs), , drop = FALSE]
my_df <- my_df[my_df$nucs > 0, , drop = FALSE]
#head(my_df)
#range(my_df$nucs)

pn <- ggplot(my_df, aes(x = nucs))
#pn <- pn + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pn <- pn + geom_histogram(bins=30, fill = "#AD26FA")
pn <- pn + theme_bw()
#pn <- pn + xlim(c(0,1))
pn <- pn + xlab("Any base (N,n)")
pn <- pn + ylab("Count")
pn <- pn + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pn <- pn + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pn
```


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("n","N")]))
names(my_df) <- "nucs"
report <- data.frame(
  row.names = c("Maximum", "Median", "Minimum", "Number", "Number0", "Number!NA")
)
report$Value <- 0
report

if( nrow(my_df) > 0 ){
  report$Value[ 1 ] <-  max(my_df$nucs, na.rm = TRUE)
  report$Value[ 2 ] <-  median(my_df$nucs, na.rm = TRUE)
  report$Value[ 3 ] <-  min(my_df$nucs, na.rm = TRUE)
  report$Value[ 4 ] <-  length(my_df$nucs)
  report$Value[ 5 ] <-  sum(my_df$nucs > 0)
  report$Value[ 6 ] <-  length(!is.na(my_df$nucs))
}
knitr::kable(report)
```




```{r}
my_df <- as.data.frame(
  my_nucs$Length - 
  rowSums(my_nucs[,c("a", "A", "c", "C", "g", "G", "t", "T", "w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y", "n", "N")]))
names(my_df) <- "nucs"
my_df$nucs <- my_df$nucs/my_nucs$Length

my_df <- my_df[!is.na(my_df$nucs), , drop = FALSE]
my_df <- my_df[my_df$nucs > 0, , drop = FALSE]
#
head(my_df)

pe <- ggplot(my_df, aes(x = nucs))
#pe <- pe + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pe <- pe + geom_histogram(bins=30, fill = "#AD26FA")
pe <- pe + theme_bw()
pe <- pe + xlim(c(0,1))
#pe <- pe + xlab("Unexpected characters")
pe <- pe + xlab("Unexpected")
pe <- pe + ylab("Count")
pe <- pe + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pe <- pe + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pe
```


```{r}
my_df <- as.data.frame(
  my_nucs$Length - 
  rowSums(my_nucs[,c("a", "A", "c", "C", "g", "G", "t", "T", "w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y", "n", "N")]))
names(my_df) <- "nucs"
report <- data.frame(
  row.names = c("Maximum", "Median", "Minimum", "Number", "Number0", "Number!NA")
)
report$Value <- 0
report

if( nrow(my_df) > 0 ){
  report$Value[ 1 ] <-  max(my_df$nucs, na.rm = TRUE)
  report$Value[ 2 ] <-  median(my_df$nucs, na.rm = TRUE)
  report$Value[ 3 ] <-  min(my_df$nucs, na.rm = TRUE)
  report$Value[ 4 ] <-  length(my_df$nucs)
  report$Value[ 5 ] <-  sum(my_df$nucs > 0)
  report$Value[ 6 ] <-  length(!is.na(my_df$nucs))
}
knitr::kable(report)
```



```{r}
my_df <- data.frame(Length = my_nucs$Length,
                    GC = rowSums(my_nucs[,c("c", "C", "g", "G")])
                    )
my_df$GC <- my_df$GC/my_df$Length
my_df$Length <- my_df$Length/1e6

pgc <- ggplot(my_df, aes(x = GC, y = Length))
pgc <- pgc + geom_point(size = 4, shape = 21, fill = "#B2222299")
pgc <- pgc + theme_bw()
pgc <- pgc + xlim(c(0,1))
# pgc <- pgc + ylab("Length (Kbp)")
pgc <- pgc + ylab("Mbp")
pgc <- pgc + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                   axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                   )
pgc <- pgc + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pgc

#my_nucs$Id[my_df$GC < 0.2]
```


We see that most sequences have a similar GC content regardless of length.
One sequence is a bit shorter than all the others and has a GC content of about a half of what the others have.
We've queried the Id above to get the accession number for this sequence.
We can then Google "NC_001224" and select the hit to NCBI and see that this sequence is the
[yeast mitochondrion](https://www.ncbi.nlm.nih.gov/nuccore/NC_001224.1).
It's been my experience that the mitochondrion will tend to have a different GC content than the nuclear sequences.


### Ideogram


Plotting of an ideogram, or cartoon, for modest numbers of sequences helps visualize the relative lengths for sequences.
For chromosome scale assemblies this may benefit from a manual step to ensure that only the chromosomes are included in the ideogram.
Other assemblies may benefit from sorting the sequences by lenght so that the longest sequences are presented.
Here we subset the sequences to the first few using an arbitrary threshold, but encourage a manual step here when possible.


```{r}
# nseq <- 10
# nseq <- 15
# nseq <- 17
# 
nseq <- 20

if( nseq > nrow(my_nucs) ){
  nseq <- nrow(my_nucs)
}

my_nucs2 <- my_nucs[1:nseq, ]
motifs <- motifs[motifs$chrom %in% my_nucs2$Id, ]
table(motifs$chrom)

#ggplot2::ggplot( data = motifs, ggplot2::aes( x = blockCount, y = score, color = chrom ) ) + ggplot2::geom_point(size = 4) + geom_smooth(method=lm, se=FALSE) + ggplot2::theme(legend.position = "none") 
```


```{r}
library(ggplot2)
chrom_wid <- 0.1

# Initialize empty plot.
p <- ggplot( )

# Add chromosomes.
p <- p + geom_rect( 
  data = my_nucs2, 
  aes( xmin = chrom_num - chrom_wid,
       xmax = chrom_num + chrom_wid,
       ymin = 1, ymax = Length),
  fill = "#DCDCDC",
  color = "#000000"
)

# Theme options.
p <- p + theme_bw()
p <- p + scale_x_continuous( 
  breaks = my_nucs2$chrom_num,
  labels = my_nucs2$Id
)
#p


if( max(my_nucs2$Length) > 1e7 ){
  yunits <- 1e7
  my_ymax <- ceiling(max(my_nucs2$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits * 10,
  )
} else if( max(my_nucs2$Length) > 1e6 ){
  yunits <- 1e6
  my_ymax <- ceiling(max(my_nucs2$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits,
  )
} else if( max(my_nucs2$Length) > 1e5 ){
  yunits <- 1e5
  my_ymax <- ceiling(max(my_nucs2$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits * 0.1,
  )
}



#  breaks = seq( 0, my_ymax, by = yunits * 1e2),
#  labels = seq( 0, my_ymax/1e3, by = 1e2),
#  breaks = seq( 0, my_ymax, by = yunits * 2e-1),
#  labels = seq( 0, my_ymax/yunits, by = 2e-1),
#)
#p <- p + ggplot2::ylab("Position (Kbp)")
p <- p + ggplot2::ylab("Position (Mbp)")

#p
p <- p + ggplot2::theme( 
    panel.grid.minor.x = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 3 ),
    axis.text.x = element_text(angle = 60, hjust = 1),
    axis.title.x=element_blank(),
    panel.grid.major.y = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 1 ),
    panel.grid.minor.y = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 3 )
  )
#p
#p <- p + ggtitle( "My sequences" )
#
```


```{r, fig.width=10}
p

# Uncomment here, and comment the 'motif windows' section below to include ideogram instead of windows graphics.
# 
pwin <- p
```


### Motif windows

```{r}
library(ggplot2)
#motifs[1:3, ]
#motifs$wincol
# Initialize empty plot.
#p <- ggplot( )

# Add windows.
p <- p + geom_rect( 
  data = motifs, 
  aes( xmin = chrom_num - score/1e3 * 0.4,
      xmax = chrom_num + score/1e3 * 0.4,
       ymin = chromStart, ymax = chromEnd),
  fill = motifs$wincol,
  color = "#00000055"
)

```


```{r, fig.width=10}
p
# Uncomment to include window graphic instead of ideogram (above).
# 
pwin <- p
```





## Dashboard


For internal purposes we may want a detailed report, as presented above.
If we want to publish this information we may want to summarize this information in a single, multipanel graphic, or dashboard perspective.
This is illustrated below.


```{r, fig.height=8, fig.width=8, fig.cap="**Figure X.** Summary of the assembly (FAST[AQ]) file. **Panel A** summarizes the distribution of sequence lengths in the assembly. **Panel B** summarizes the per sequence distribution for the rate of each nucleotide (case insensitive). **Panel C** is an ideogram (cartoon) for the first sequences where the height of each bar represents the sequence length and the with and color for windows is based on the per window inverse abundance of the 'CG' motif. **Panels D, E, and F** summarize the occurrence of IUPAC ambiguous nucleotides (wWsSmMkKrRyY), any nucelotide (nN), and any unexpected nucleotides on a per sequence/contig basis. **Panel G** presents the relationship between the length of each sequence/contig and it's G/C content."}

library(ggpubr)

# ggarrange(pl, pat,
#           ncol = 2, nrow = 1,
#           labels = c("A", "B"),
#           widths = c(1, 1.2)
# )

# pwin

# ggarrange(pu, pn, pe, pgc, ncol = 4, nrow = 1, 
#             labels = c("F", "G", "H", "I"),  
#             font.label = list(size = 10, color = "black", face = "bold", family = NULL))


ggarrange(
  ggarrange(pl, pat,
          ncol = 2, nrow = 1,
          labels = c("A", "B"),
          widths = c(1, 1.2)
  ),
  pwin,
  ggarrange(pu, pn, pe, pgc, ncol = 4, nrow = 1, 
            labels = c("D", "E", "F", "G"),  
            font.label = list(size = 10, color = "black", face = "bold", family = NULL)),
  ncol = 1, nrow = 3,
  labels = c("", "C", ""),
  heights = c(2.0, 2.5, 1)
)


# ggsave(filename = paste(my_out, ".png", sep = ""), device = "png",
#        width = 6.5, height = 6.5, units = "in")
# ggsave(filename = paste(my_out, ".tiff", sep = ""), device = "tiff",
#        width = 6.5, height = 6.5, units = "in", compression = "lzw")
```


For the purpose of publication we may desire to save this "dashboard" as a graphic.
After the above code has been run, the ```ggsave()``` function can be uncommented and run.
You'll want to include a meaningful filename.
This will save the dashboard as a ```*.png``` or ```*.tiff``` graphic.


## Tabular output

A tabular presentation of the data may also be desirable.
Below is an example of a tabular presentation.


```{r}
genome_df <- data.frame(matrix(
  c(
    "Total length (bp)", sum(my_nucs$Length),
    "Number of sequences (count)", nrow(my_nucs),
    "N50 (bp)", n50,
    "Median length (bp)", median(my_nucs$Length),
    "Maximum length (bp)", max(my_nucs$Length),
    "Tenth longest sequence (bp)", sort(my_nucs$Length, decreasing = TRUE)[10],
    "Total A,a,C,c,G,g,T,t (bp)", sum(colSums(my_nucs[, c("A", "a", "C", "c", "G", "g", "T", "t")])),
    "Total C,c,G,g (bp)", sum(colSums(my_nucs[, c("C", "c", "G", "g")])),
    "GC/ACGT (percentage)", sum(colSums(my_nucs[, c("C", "c", "G", "g")]))/sum(colSums(my_nucs[, c("A", "a", "C", "c", "G", "g", "T", "t")])) * 1e2,
    "GC/Total length (percentage)", sum(colSums(my_nucs[, c("C", "c", "G", "g")]))/sum(my_nucs$Length) * 1e2,
    "Number of Nn", sum(colSums(my_nucs[, c("N", "n")])),
    "Number of IUPAC ambiguous: wWsSmMkKrRyY", sum(colSums(my_nucs[, c("w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y")])),
    "Number of unexpected", sum(my_nucs$Length) - sum(rowSums(my_nucs[,c("a", "A", "c", "C", "g", "G", "t", "T", "w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y", "n", "N")]))
#)
  ),
  ncol = 2, byrow = TRUE
))
genome_df <- as.data.frame(genome_df)
names(genome_df) <- c("Category", "Value")
genome_df$Value <- as.numeric(genome_df$Value)

proc_time <- Sys.time() - st1
genome_df <- rbind(genome_df, c("Processing time", format( proc_time, units = "mins")))

knitr::kable(genome_df, 
             digits = 3, 
             format.args = list(scientific = FALSE, big.mark = ","),
             caption = "**Table X** Summary of the sequences.")
```


In order to use this information in other analyses it may be desirable to provide a form suitable for copy and paste operations.
This can be accomplished with modest size datasets using the command `dput()`.


```{r, comment=NA}
# 
genome_df <- t(genome_df)
colnames( genome_df ) <- genome_df[1, ]
genome_df <- genome_df[-1, , drop = FALSE]
#
dput(genome_df)
```


File output can be accomplished with the following example that outputs to comma delimited format.


```{r, comment=NA}
write.table( x = genome_df, 
#             file = "fasta2nuccomp_summary.csv",
             file = paste(my_out, "_nuccomp_summary.csv", sep = ""),
             sep = ",",
             row.names = FALSE, col.names = TRUE )
```



## Session information


After performing the above operations we may wish to benchmark the execution time in order to determine how feasible it is to repeat this analysis.
This has been facilitated above by taking time stamps with the function ```Sys.time()```.
We can now use these timestamps to evaluate total execution time.


```{r}
st4 <- Sys.time()
st4 - st1
```


Lastly, we can use the ```sessionInfo()``` function to report the version of ```R()``` we are using as well as the packages and their versions.
This is important information to include if we want to report an issue.


```{r}
sessionInfo()
```

